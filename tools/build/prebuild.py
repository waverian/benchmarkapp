#!/usr/bin/env python
"""
Usage: "prebuild.py [options] <path>

Options:
    --inline_kv         Finds all <filename>.kv files and inlines them into <filename>.py.
    --cythonize         Cythonize the .py files to .o modules.
    --bootstrap         Create a bootstrap module one big jiant bootstrap.o file.

"""

import jinja2
import sys
from sysconfig import get_paths
from subprocess import Popen
import os
from os.path import dirname, join, realpath, sep
from os import walk, makedirs, environ
from sys import platform, exit, argv, executable
from shutil import rmtree, copytree, copy, move
BUILD_DIR='.'

def setup_dirs(BUILDDIR='build_standard'):
    global BUILD_DIR
    BUILD_DIR = BUILDDIR
    print(BUILDDIR, 'BUILDDIR')
    globals() ['PROJECTPATH'] = realpath(join(os.getcwd(), BUILDDIR))
    # general config
    globals()['root_dir'] = realpath(join(dirname(__file__), '..', '..'))
    globals() ['build_dir'] = realpath(join(root_dir, BUILDDIR, 'build'))
    globals() ['standard_dir'] = realpath(join(root_dir, BUILDDIR))
    globals() ['bootstrap_dir'] = realpath(join(root_dir, BUILDDIR, 'build', 'bootstrap'))
    globals() ['blacklist'] = ('build', 'main.py', 'mods', 'plyer')

bootstrap_template = r'''
#include <Python.h>
#include <locale.h>
#include <stdio.h>
#include <stdlib.h>

#ifdef __FreeBSD__
#include <floatingpoint.h>
#endif

# define MODINIT(name)  PyInit_ ## name

{% for modname, entrypoint in modules %}
PyMODINIT_FUNC MODINIT({{ entrypoint }}) (void);{% endfor %}

static struct _inittab inittab[] = {
{% for modname, entrypoint in modules %}
    { "{{ entrypoint }}", MODINIT({{ entrypoint }}) },{% endfor %}
    { NULL, NULL }
};

static struct PyModuleDef {{ name }} =
{
    PyModuleDef_HEAD_INIT,
    "{{ name }}}", /* name of module */
    "",          /* module documentation, may be NULL */
    -1,          /* size of per-interpreter state of the module, or -1 if the module keeps state in global variables. */
    NULL
};

PyMODINIT_FUNC
MODINIT({{ name }})(void)
{
    PyObject *m, *d, *l;

    m = PyModule_Create(&{{ name }});
    if (PyImport_ExtendInittab(inittab)) {
        fprintf(stderr, "No memory\\n");
        exit(1);
    }

    l = PyList_New(0);
    {% for modname, entrypoint in modules %}
    PyList_Append(l, PyUnicode_FromString("{{ modname }}"));{% endfor %}
    d = PyModule_GetDict(m);
    PyDict_SetItemString(d, "modules", l);
}
'''

class Commands(object):

    def get_module_name(self, f):
        f = f[:-3]
        if f.endswith(sep + '__init__'):
            f = f[:-9]
        return f.replace(sep, '.')

    def get_module_filename(self, f):
        f = f[:-3]
        if f.endswith(sep + '__init__'):
            f = f[:-9]
        return f.replace(sep, '_') + '.py'

    def command(self, cmd, **kwargs):
        print('-', cmd)
        process = Popen(cmd, **kwargs)
        process.communicate()
        if process.returncode != 0:
            raise SystemError(str(cmd))

    def do_compile_kv(self):
        '''Create a compiled version of the kv files in your project.
        '''
        from pathlib import Path
        kv_files = []
        for ofile in sorted(Path(PROJECTPATH).glob('**/*.kv')):
            print(f'found {ofile}')
            kv_files.append(ofile)
            with open(ofile) as fd:
                data = fd.read()

            data = data.replace('\\', '\\\\')
            compiled_fn = 'compiled_' + ofile.name.rsplit('/')[-1].split('.')[0] + '.py'

            print(f'Inlining {ofile.name} to {compiled_fn} .\n')
            with open(f'{PROJECTPATH}/{compiled_fn}', 'w') as fd:
                fd.write(f'''
# Autogenerated file, don\'t modify directly
from kivy.lang import Builder
root = Builder.load_string("""{data}""")''')
            print(f'Deleting {ofile} .\n')
            os.unlink(ofile)

        print('No kv files found, exiting!' if not kv_files else 'Done!')

    def setup_flags(self):
        cmd = self.command
        cc = 'gcc'
        cython = ['cython']
        cflags = ['-fno-strict-aliasing', '-fno-common', '-fwrapv', '-Wall']
        cflags += ['-DNDEBUG']
        ldflags = []

        ext = 'so'
        
        sys_version = sys.version.split(' ')[0][:4]
        if platform == 'darwin':
            cc = 'llvm-gcc'
            cflags += ['-Wstrict-prototypes', f'-I{get_paths()["include"]}']
            cflags += [f'-I{BUILD_DIR}/../python3/include/python{sys_version}']
            ldflags += ['-bundle', '-undefined', 'dynamic_lookup', '-isysroot', '/', '-L', '/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/lib']
            import platform as pyplatform
            arch = pyplatform.uname().machine
            cflags += ['-arch', arch]
            ldflags += ['-arch', arch]
            # if building on M1, build universal lib
            if arch == 'arm64':
                cflags += ['-arch', 'x86_64']
                ldflags += ['-arch', 'x86_64']
            ldflags += ['-disable-opt', '-disable-inlining']

        if platform in ('linux', 'linux3'):
            import sh
            cflags += sh.pkg_config('--cflags', 'python3').split(' ')[:-1]
            cflags += ['-Wstrict-prototypes', f'-I/usr/include/python{sys_version}', f'-I/usr/local/include/python{sys_version}', '-fPIC']
            ldflags += ['-shared']
        if platform == 'win32':
            sys_version = ''.join(sys_version.split('.'))
            cc = 'cl'
            cython = [executable, '-m', 'cython']
            cflags += [f'-Ic:\\Program Files\\Python38\\include']
            cflags += ['/O2', '/openmp', '/favor:INTEL64', '/MD']
            ldflags += [f'/link', '/DLL', '/LIBPATH:C:\\Program Files\\Python38\\libs']
            ext = 'pyd'
        else:
            cflags += ['-O3']
        try:
            rmtree(bootstrap_dir)
        except:
            pass

        return cmd, cc, cython, cflags, ldflags, ext
    
    def get_all_pyfiles(self):
        '''Return all the python files of our application
        '''
        pyfiles = []
        for root, sub, files in walk(PROJECTPATH):
            if root[len(PROJECTPATH)+1:].split(sep)[0] in blacklist:
                continue
            sub = [x for x in sub if x not in blacklist]
            for fn in files:
                if fn[-3:] != '.py':
                    continue
                if fn in blacklist:
                    continue
                pyfiles.append((root, fn))
        
        return pyfiles

    def do_cythonize(self):
        self.cythonize_files(self.get_all_pyfiles())

    def cythonize_files(self, pyfiles):

        cmd, cc, cython, cflags, ldflags, ext = self.setup_flags()

        # cythonize them
        pymodules = []
        objects = []
        if not pyfiles:
            print('No python files to cythonize')
            return

        def _cythonize_file(args):
            relative_fn = os.path.join(*args)
            relative_fn_noext = relative_fn[:-2]
            obj = relative_fn_noext + 'o'
            src = relative_fn_noext + 'c'

            cmd(cython + [relative_fn] + ['-3'])

            if platform == 'win32':
                cmd([cc, '-c', src, '-Fo' + obj] + cflags)
                cmd([cc, obj, '/Fe' + relative_fn_noext + 'pyd'] + ldflags)
            else:
                cmd([cc, '-c', src, '-o', obj] + cflags)
                cmd([cc, obj, '-o', relative_fn_noext + 'so'] + ldflags)

            for ext in ('py', 'c', 'o') + (('exp', 'lib', ) if platform == 'win32' else ()):
                print(f"Deleting {relative_fn_noext + ext}")
                os.unlink(relative_fn_noext + ext)
            # cmd(['ls', os.path.join(*args[:-1])])
                
        from concurrent.futures import ThreadPoolExecutor
        with ThreadPoolExecutor() as executor:
            for result in executor.map(_cythonize_file, pyfiles):
                # just iterate over results to get exceptions propagated
                pass

        print('Done Cythonizing!')

    def do_bootstrap(self):
        '''Create a single python library that contain all the python file of
        our application
        '''
        cmd, cc, cython, cflags, ldflags, ext = self.setup_flags()

        if not os.path.exists(bootstrap_dir): makedirs(bootstrap_dir)

        # get all the python files
        pyfiles = self.get_all_pyfiles()

        # cythonize them
        pymodules = []
        objects = []
        for root, fn in pyfiles:
            relative_fn = realpath(join(root, fn))[len(standard_dir)+1:]
            module_name = self.get_module_name(relative_fn)
            module_fn = self.get_module_filename(relative_fn)
            module_full_fn = join(bootstrap_dir, module_fn)

            with open(join(root, fn)) as fd:
                content = fd.read()

            with open(module_full_fn, 'w') as fd:
                fd.write('__path__ = %r\n' % module_name)
                fd.write(content)

            obj = module_full_fn[:-2] + 'o'
            cmd(cython + [module_full_fn] + ['-3'])
            cmd([cc, '-c', module_full_fn[:-2] + 'c', '-o', obj] + cflags)
            pymodules.append([module_name, module_fn[:-3]])
            objects.append(obj)

        # generate the bootstrap file
        bootstrap = jinja2.Template(bootstrap_template)
        bootstrap_fn = join(bootstrap_dir, 'bootstrap.c')
        with open(bootstrap_fn, 'w') as fd:
            fd.write(bootstrap.render(name='bootstrap', modules=pymodules))
        
        # compile the bootstrap
        bootstrap_obj = bootstrap_fn[:-1] + 'o'
        cmd([cc, '-c', bootstrap_fn, '-o', bootstrap_obj] + cflags)
        objects.append(bootstrap_obj)

        # assemble everything
        bootstrap_modfn = join(bootstrap_dir, 'bootstrap.' + ext)
        cmd([cc] + ldflags + objects + ['-o', bootstrap_modfn])

        # copy missing files
        copy(join(standard_dir, 'main.py'), bootstrap_dir)
        copytree(join(standard_dir, 'data'), join(bootstrap_dir, 'data'))


if __name__ == '__main__':
    from docopt import docopt
    arguments = docopt(__doc__, version='0.0.1')
    setup_dirs(arguments['<path>'])
    if arguments['--inline_kv']:
        Commands().do_compile_kv()
    elif arguments['--cythonize']:
        Commands().do_cythonize()
    elif arguments['--bootstrap']:
        Commands().do_bootstrap()
